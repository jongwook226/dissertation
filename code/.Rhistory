if(a3[1] < a3[3] || a3[1] < a3[3]){
stop("\nwrong parameter values!\n")
}
if(kappa==0){
tau <- data.frame(tau_lat=0, tau_long=0)
}else{
tau <- data.frame(tau_lat=rep(0,kappa^2), tau_long=rep(0,kappa^2))
# #using the same tau
#   tau$tau_lat <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
#   tau$tau_long <- runif(1, min=0, max=2*pi) #tau_longitude
#using different taus
for(i in 1:kappa^2){
#random sampling for tau
tau$tau_lat[i] <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
tau$tau_long[i] <- runif(1, min=0, max=2*pi) #tau_longitude
}
}
n <- P*t #total data size
lat <- runif(P, min=-pi/2, max=pi/2) #latitude
long <- runif(P, min=0, max=2*pi) #longitude
time <- rep(1:t, each=P)
####################### Get Spherical distance matrix by cpp code ######################
dyn.load("C_dissertation.so")
#is.loaded('SphDist')
#is.loaded('Cov_mat')
#is.loaded('G_hat')
#dyn.unload("C_dissertation.so")
dat <- data.frame(lat,long)
#save spherical distance matrix
sDmat <- C_SphDist(dat)
#save the values of Spherical harmonics of the truncated parts
low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(low_spherical) <- c("Y00", "Y1n1", "Y10", "Y11")
if(kappa==2){
low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y00),t)
low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y1n1),t)
low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y10),t)
low_spherical$Y11 <- rep(apply(dat[,1:2],1,Y11),t)
# low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y.0.0),t)
# low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y.n1.1),t)
# low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y.0.1),t)
# low_spherical$Y11 <- rep(apply(dat[,1:2],1,Y.1.1),t)
#values of low order spherical harmonics for tau
#tau_spherical <- c(Y00(c(tau_lat,tau_long)), Y1n1(c(tau_lat,tau_long)), Y10(c(tau_lat,tau_long)), Y11(c(tau_lat,tau_long)))
#tau_spherical <- c(Y.0.0(c(tau_lat,tau_long)), Y.n1.1(c(tau_lat,tau_long)), Y.0.1(c(tau_lat,tau_long)), Y.1.1(c(tau_lat,tau_long)))
}
#Spherical distance b/w dataset and taus
if(kappa==0){
tauDist <- bwtauDist <- 0
}else{
tauDist <- data.frame(matrix(rep(0, P*(kappa^2)), ncol=kappa^2))
if(kappa != 0){ #we do not need tau if kappa =0
for(i in 1:P){
for(j in 1:(kappa^2)){
tauDist[i,j] <- SphDist(dat[i,1], dat[i,2], tau$tau_lat[j], tau$tau_long[j])
}
}
}
tauDist <- as.data.frame(lapply(tauDist, rep, t))
for(i in 1:kappa^2){
colnames(tauDist)[i] <- paste("tauDist",i, sep="")
}
#Spherical distance b/w taus
bwtauDist <- matrix(0, nrow=kappa^2, ncol=kappa^2)
for(i in 1:kappa^2){
for(j in i:kappa^2){
bwtauDist[i,j] <- bwtauDist[j,i] <- SphDist(tau$tau_lat[i], tau$tau_long[i], tau$tau_lat[j], tau$tau_long[j])
}
}
}
index <- 1:P #index of spatial locations (we use it to avoid redundancy of computation of distances)
dat <- data.frame(dat,time,index)
dat
tauDist
low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y00),t)
low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y1n1),t)
low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y10),t)
a1=c(0.8,0.8,0.8); a2=c(0.1,0.1,0.1); a3=c(1,1,1)
P <- 200 #location data size
t <- 20 #time data size
P <- 100 #location data size
t <- 10 #time data size
kappa <- 2 #IRF order
#Check constrains of the parameter values
if(a1[1] < a1[3] || a1[1] < a1[3]){
stop("\nwrong parameter values!\n")
}
if(a2[1] > a2[3] || a2[1] > a2[3]){
stop("\nwrong parameter values!\n")
}
if(a3[1] < a3[3] || a3[1] < a3[3]){
stop("\nwrong parameter values!\n")
}
if(kappa==0){
tau <- data.frame(tau_lat=0, tau_long=0)
}else{
tau <- data.frame(tau_lat=rep(0,kappa^2), tau_long=rep(0,kappa^2))
# #using the same tau
#   tau$tau_lat <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
#   tau$tau_long <- runif(1, min=0, max=2*pi) #tau_longitude
#using different taus
for(i in 1:kappa^2){
#random sampling for tau
tau$tau_lat[i] <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
tau$tau_long[i] <- runif(1, min=0, max=2*pi) #tau_longitude
}
}
n <- P*t #total data size
lat <- runif(P, min=-pi/2, max=pi/2) #latitude
long <- runif(P, min=0, max=2*pi) #longitude
time <- rep(1:t, each=P)
####################### Get Spherical distance matrix by cpp code ######################
dyn.load("C_dissertation.so")
#is.loaded('SphDist')
#is.loaded('Cov_mat')
#is.loaded('G_hat')
#dyn.unload("C_dissertation.so")
dat <- data.frame(lat,long)
#save spherical distance matrix
sDmat <- C_SphDist(dat)
#save the values of Spherical harmonics of the truncated parts
low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(low_spherical) <- c("Y00", "Y1n1", "Y10", "Y11")
if(kappa==2){
low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y00),t)
low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y1n1),t)
low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y10),t)
low_spherical$Y11 <- rep(apply(dat[,1:2],1,Y11),t)
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
p2 <- function(x, i, A){
Y <- c(Y00(x), Y1n1(x), Y10(x), Y11(x))
as.numeric(A[i,1:4] %*% Y)
}
p2(y, v, A)
# low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y.0.0),t)
# low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y.n1.1),t)
# low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y.0.1),t)
# low_spherical$Y11 <- rep(apply(dat[,1:2],1,Y.1.1),t)
#values of low order spherical harmonics for tau
#tau_spherical <- c(Y00(c(tau_lat,tau_long)), Y1n1(c(tau_lat,tau_long)), Y10(c(tau_lat,tau_long)), Y11(c(tau_lat,tau_long)))
#tau_spherical <- c(Y.0.0(c(tau_lat,tau_long)), Y.n1.1(c(tau_lat,tau_long)), Y.0.1(c(tau_lat,tau_long)), Y.1.1(c(tau_lat,tau_long)))
}
low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y00),t)
low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y1n1),t)
low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y10),t)
low_spherical$Y11 <- rep(apply(dat[,1:2],1,Y11),t)
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
A2
low_spherical
a1=c(0.8,0.8,0.8); a2=c(0.1,0.1,0.1); a3=c(1,1,1)
P <- 200 #location data size
t <- 20 #time data size
P <- 100 #location data size
t <- 10 #time data size
kappa <- 2 #IRF order
#Check constrains of the parameter values
if(a1[1] < a1[3] || a1[1] < a1[3]){
stop("\nwrong parameter values!\n")
}
if(a2[1] > a2[3] || a2[1] > a2[3]){
stop("\nwrong parameter values!\n")
}
if(a3[1] < a3[3] || a3[1] < a3[3]){
stop("\nwrong parameter values!\n")
}
if(kappa==0){
tau <- data.frame(tau_lat=0, tau_long=0)
}else{
tau <- data.frame(tau_lat=rep(0,kappa^2), tau_long=rep(0,kappa^2))
# #using the same tau
#   tau$tau_lat <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
#   tau$tau_long <- runif(1, min=0, max=2*pi) #tau_longitude
#using different taus
for(i in 1:kappa^2){
#random sampling for tau
tau$tau_lat[i] <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
tau$tau_long[i] <- runif(1, min=0, max=2*pi) #tau_longitude
}
}
n <- P*t #total data size
lat <- runif(P, min=-pi/2, max=pi/2) #latitude
long <- runif(P, min=0, max=2*pi) #longitude
time <- rep(1:t, each=P)
####################### Get Spherical distance matrix by cpp code ######################
dyn.load("C_dissertation.so")
#is.loaded('SphDist')
#is.loaded('Cov_mat')
#is.loaded('G_hat')
#dyn.unload("C_dissertation.so")
dat <- data.frame(lat,long)
#save spherical distance matrix
sDmat <- C_SphDist(dat)
#setwd("/Users/jongwookkim/Library/CloudStorage/OneDrive-IndianaUniversity/IU/Dissertation")
setwd("/Users/jongwookkim/Documents/dissertation/code")
source("functions_dissertation.R")
source("irfkrg-fcn01-sphere-harmonics.R")
source("irfkrg-fcn02-legendre-polynomials.R")
a1=c(0.8,0.8,0.8); a2=c(0.1,0.1,0.1); a3=c(1,1,1)
P <- 200 #location data size
t <- 20 #time data size
P <- 100 #location data size
t <- 10 #time data size
kappa <- 2 #IRF order
#Check constrains of the parameter values
if(a1[1] < a1[3] || a1[1] < a1[3]){
stop("\nwrong parameter values!\n")
}
if(a2[1] > a2[3] || a2[1] > a2[3]){
stop("\nwrong parameter values!\n")
}
if(a3[1] < a3[3] || a3[1] < a3[3]){
stop("\nwrong parameter values!\n")
}
if(kappa==0){
tau <- data.frame(tau_lat=0, tau_long=0)
}else{
tau <- data.frame(tau_lat=rep(0,kappa^2), tau_long=rep(0,kappa^2))
# #using the same tau
#   tau$tau_lat <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
#   tau$tau_long <- runif(1, min=0, max=2*pi) #tau_longitude
#using different taus
for(i in 1:kappa^2){
#random sampling for tau
tau$tau_lat[i] <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
tau$tau_long[i] <- runif(1, min=0, max=2*pi) #tau_longitude
}
}
n <- P*t #total data size
lat <- runif(P, min=-pi/2, max=pi/2) #latitude
long <- runif(P, min=0, max=2*pi) #longitude
time <- rep(1:t, each=P)
####################### Get Spherical distance matrix by cpp code ######################
dyn.load("C_dissertation.so")
#is.loaded('SphDist')
#is.loaded('Cov_mat')
#is.loaded('G_hat')
#dyn.unload("C_dissertation.so")
dat <- data.frame(lat,long)
#save spherical distance matrix
sDmat <- C_SphDist(dat)
#save the values of Spherical harmonics of the truncated parts
low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(low_spherical) <- c("Y00", "Y1n1", "Y10", "Y11")
dat
low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y00),t)
low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y1n1),t)
low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y10),t)
low_spherical$Y11 <- rep(apply(dat[,1:2],1,Y11),t)
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
low_spherical
low_spherical$Y00 <- apply(dat[,1:2],1,Y00)
low_spherical$Y1n1 <- apply(dat[,1:2],1,Y1n1)
low_spherical$Y10 <- apply(dat[,1:2],1,Y10)
low_spherical$Y11 <- apply(dat[,1:2],1,Y11)
#save the values of Spherical harmonics of the truncated parts
#low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(low_spherical) <- c("Y00", "Y1n1", "Y10", "Y11")
low_spherical$Y00 <- apply(dat[,1:2],1,Y00)
low_spherical$Y1n1 <- apply(dat[,1:2],1,Y1n1)
low_spherical$Y10 <- apply(dat[,1:2],1,Y10)
low_spherical$Y11 <- apply(dat[,1:2],1,Y11)
low_spherical$Y00
low_spherical
#setwd("/Users/jongwookkim/Library/CloudStorage/OneDrive-IndianaUniversity/IU/Dissertation")
setwd("/Users/jongwookkim/Documents/dissertation/code")
source("functions_dissertation.R")
source("irfkrg-fcn01-sphere-harmonics.R")
source("irfkrg-fcn02-legendre-polynomials.R")
a1=c(0.8,0.8,0.8); a2=c(0.1,0.1,0.1); a3=c(1,1,1)
P <- 200 #location data size
t <- 20 #time data size
P <- 100 #location data size
t <- 10 #time data size
kappa <- 2 #IRF order
#Check constrains of the parameter values
if(a1[1] < a1[3] || a1[1] < a1[3]){
stop("\nwrong parameter values!\n")
}
if(a2[1] > a2[3] || a2[1] > a2[3]){
stop("\nwrong parameter values!\n")
}
if(a3[1] < a3[3] || a3[1] < a3[3]){
stop("\nwrong parameter values!\n")
}
if(kappa==0){
tau <- data.frame(tau_lat=0, tau_long=0)
}else{
tau <- data.frame(tau_lat=rep(0,kappa^2), tau_long=rep(0,kappa^2))
# #using the same tau
#   tau$tau_lat <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
#   tau$tau_long <- runif(1, min=0, max=2*pi) #tau_longitude
#using different taus
for(i in 1:kappa^2){
#random sampling for tau
tau$tau_lat[i] <- runif(1, min=-pi/2, max=pi/2) #tau_latitude
tau$tau_long[i] <- runif(1, min=0, max=2*pi) #tau_longitude
}
}
n <- P*t #total data size
lat <- runif(P, min=-pi/2, max=pi/2) #latitude
long <- runif(P, min=0, max=2*pi) #longitude
time <- rep(1:t, each=P)
####################### Get Spherical distance matrix by cpp code ######################
dyn.load("C_dissertation.so")
#is.loaded('SphDist')
#is.loaded('Cov_mat')
#is.loaded('G_hat')
#dyn.unload("C_dissertation.so")
dat <- data.frame(lat,long)
#save spherical distance matrix
sDmat <- C_SphDist(dat)
#save the values of Spherical harmonics of the truncated parts
#low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(low_spherical) <- c("Y00", "Y1n1", "Y10", "Y11")
if(kappa==2){
low_spherical$Y00 <- apply(dat[,1:2],1,Y00)
low_spherical$Y1n1 <- apply(dat[,1:2],1,Y1n1)
low_spherical$Y10 <- apply(dat[,1:2],1,Y10)
low_spherical$Y11 <- apply(dat[,1:2],1,Y11)
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
q2 <- function(x, i, A){
Y <- c(Y00(x), Y1n1(x), Y10(x), Y11(x))
as.numeric(A[i,1:4] %*% Y)
}
p2(y, v, A)
# low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y00),t)
# low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y1n1),t)
# low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y10),t)
# low_spherical$Y11 <- rep(apply(dat[,1:2],1,Y11),t)
# low_spherical$Y00 <- rep(apply(dat[,1:2],1,Y.0.0),t)
# low_spherical$Y1n1 <- rep(apply(dat[,1:2],1,Y.n1.1),t)
# low_spherical$Y10 <- rep(apply(dat[,1:2],1,Y.0.1),t)
# low_spherical$Y11 <- rep(apply(dat[,1:2],1,Y.1.1),t)
#values of low order spherical harmonics for tau
#tau_spherical <- c(Y00(c(tau_lat,tau_long)), Y1n1(c(tau_lat,tau_long)), Y10(c(tau_lat,tau_long)), Y11(c(tau_lat,tau_long)))
#tau_spherical <- c(Y.0.0(c(tau_lat,tau_long)), Y.n1.1(c(tau_lat,tau_long)), Y.0.1(c(tau_lat,tau_long)), Y.1.1(c(tau_lat,tau_long)))
}
#save the values of Spherical harmonics of the truncated parts
#low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)))
colnames(low_spherical) <- c("Y00", "Y1n1", "Y10", "Y11")
low_spherical$Y00 <- apply(dat[,1:2],1,Y00)
low_spherical$Y1n1 <- apply(dat[,1:2],1,Y1n1)
low_spherical$Y10 <- apply(dat[,1:2],1,Y10)
low_spherical$Y11 <- apply(dat[,1:2],1,Y11)
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
low_spherical
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
dim(low_spherical)
A2
A2%*%
head(low_spherical)
A2%*%
head(low_spherical)
A2%*%
head(low_spherical)
head(low_spherical)
A2
A2%*%t(low_spherical)
head(low_spherical)
A2%*%t(low_spherical)
q2 <- A2%*%t(low_spherical)
q2
q2
dim(q)
dim(q2)
dim(low_spherical)
q2 <- low_spherical%*%t(A2)
low_spherical
t(A2)
q2 <- low_spherical%*%t(A2)
q2 <-
dim(low_spherical)
dim(low_spherical)
q2 <- low_spherical %*% A2
q2 <- low_spherical %*% A2
q2 <- as.matrix(low_spherical)%*%A2
as.matrix(low_spherical)
low_spherical
q2 <- as.matrix(low_spherical)%*%t(A2)
q2
dim(q2)
q2 <- A2%*%t(low_spherical)
q2 <- as.matrix(low_spherical)%*%t(A2)
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
q2 <- A2%*%t(low_spherical)
q2 <- as.matrix(low_spherical)%*%t(A2)
dim(low_spherical)
dim(q2)
dim(q_2)
dim(q2)
#q2 <- A2%*%t(low_spherical)
q2 <- rep(as.matrix(low_spherical)%*%t(A2),t)
#Creat q function, which is the Nil basis
q <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
#save the values of Spherical harmonics of the truncated parts
#low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)))
colnames(low_spherical) <- c("Y00", "Y1n1", "Y10", "Y11")
low_spherical$Y00 <- apply(dat[,1:2],1,Y00)
low_spherical$Y1n1 <- apply(dat[,1:2],1,Y1n1)
low_spherical$Y10 <- apply(dat[,1:2],1,Y10)
low_spherical$Y11 <- apply(dat[,1:2],1,Y11)
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
#q2 <- A2%*%t(low_spherical)
q2 <- rep(as.matrix(low_spherical)%*%t(A2),t)
q2
dim(q2)
#Creat q function, which is the Nil basis
q <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
#save the values of Spherical harmonics of the truncated parts
#low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
low_spherical <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)))
colnames(low_spherical) <- c("Y00", "Y1n1", "Y10", "Y11")
low_spherical$Y00 <- apply(dat[,1:2],1,Y00)
low_spherical$Y1n1 <- apply(dat[,1:2],1,Y1n1)
low_spherical$Y10 <- apply(dat[,1:2],1,Y10)
low_spherical$Y11 <- apply(dat[,1:2],1,Y11)
A2 <- solve(matrix(c(apply(tau,1,Y00),
apply(tau,1,Y1n1),
apply(tau,1,Y10),
apply(tau,1,Y11)),
4, 4, byrow = T))
#q <- A2%*%t(low_spherical)
q <- rep(as.matrix(low_spherical)%*%t(A2),t)
q
dim(q)
#Creat q function, which is the Nil basis
q <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
#q <- A2%*%t(low_spherical)
q <- as.matrix(low_spherical)%*%t(A2)
q
tau
q
#Creat q function, which is the Nil basis
q <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(low_spherical) <- c("q1", "q2", "q3", "q4")
q
colnames(low_spherical) <- c("q1", "q2", "q3", "q4")
#Creat q function, which is the Nil basis
q <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(low_spherical) <- c("q1", "q2", "q3", "q4")
head(q)
#Creat q function, which is the Nil basis
q <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(q) <- c("q1", "q2", "q3", "q4")
head(q)
rep(as.matrix(low_spherical)%*%t(A2),t)
#q2 <- A2%*%t(low_spherical)
q2 <- as.matrix(low_spherical)%*%t(A2)
q2
#q2 <- A2%*%t(low_spherical)
q2 <- as.matrix(low_spherical)%*%t(A2)
q <- replicate(t, rbind(q2,q2))
q
dim(q)
t
q <- replicate(t, rbind(q2,q2))
dim(q)
dim(q2)
do.call("rbind", replicate(t, q2, simplify = FALSE))
q <- replicate(t, rbind(q2,q2))
#q2 <- A2%*%t(low_spherical)
q2 <- as.matrix(low_spherical)%*%t(A2)
q <- do.call("rbind", replicate(t, q2, simplify = FALSE))
dim(q)
#Creat q function, which is the Nil basis
q <- data.frame(matrix(0, ncol=4, nrow=nrow(dat)*t))
colnames(q) <- c("q1", "q2", "q3", "q4")
dim(q)
q <- do.call("rbind", replicate(t, q2, simplify = FALSE))
dim(q)
q[1,]
P
q[101,]
q[201,]
q[202,]
q[2,]
